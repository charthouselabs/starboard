enum PositionSide {
  LONG
  SHORT
}

enum MarketStatus {
  Active
  Paused
  CancelOnly
  PostOnly
  Initializing
  FinalSettlement
}

enum TradeType {
  Limit
  Liquidation
}

enum PositionStatus {
  OPEN
  CLOSED
  LIQUIDATED
}

enum OrderSide {
  BUY
  SELL
}

enum OrderType {
  MARKET
}

enum OrderStatus {
  Filled
}

enum MarketType {
  PERP
}

enum PaymentType {
  FUNDING,
  POSITION,
}

enum CandleResolution {
  M1
  M5
  M15
  M30
  H1
  H4
  D1
}

# type Address {
#   id: ID!
#   address: String
#   metadata: JSON
#   subaccount: Subaccount
# }

# type ClobPair {
#   id: String!
#   market: Market
# }

# type Account {
#   id: ID!
#   address: String
#   subaccountNumber: Int
#   subaccountId: String

#   # ruscet only
#   isLiquidator: Boolean
#   isHandler: Boolean
#   isManager: Boolean
#   metadata: JSON

#   owner: Address

#   #FK
#   positions: [Position!]
# }

# type Position {
#   id: ID!

#   status: PositionStatus
#   side: PositionSide
#   size: BigInt
#   maxSize: BigInt
#   entryPrice: BigDecimal
#   exitPrice: BigDecimal
#   realizedPnl: BigDecimal
#   createdAt: DateTime
#   createdAtHeight: Int
#   sumOpen: BigDecimal
#   sumClose: BigDecimal
#   netFunding: BigDecimal
#   unrealizedPnl: BigDecimal
#   closedAt: DateTime
#   subaccountNumber: Int

#   ticker: String

#   # Ruscet only
#   collateral: BigDecimal
#   positionFees: BigDecimal
#   entryFundingRate: BigDecimal
#   reserveAmount: BigDecimal
#   lastIncreasedTime: DateTime

#   #FKs
#   account: Account
#   market: Market
# }

# type Candle {
#   id: ID!
#   ticker: String
#   resolution: CandleResolution
#   startedAt: BigInt
#   open: BigDecimal
#   close: BigDecimal
#   high: BigDecimal
#   low: BigDecimal

#   baseTokenVolume: BigDecimal
#   usdVolume: BigDecimal

#   startingOpenInterest: BigDecimal

#   # relations
#   market: Market
# }

# type Market {
#   id: ID!
#   ticker: String!
#   atomicResolution: Int!
#   baseOpenInterest: String!
#   defaultFundingRate1H: String!
#   initialMarginFraction: String!
#   maintenanceMarginFraction: String!
#   marketType: MarketType!
#   nextFundingRate: String!
#   openInterest: String!
#   openInterestLowerCap: String
#   openInterestUpperCap: String
#   oraclePrice: Price
#   priceChange24H: String!
#   quantumConversionExponent: Int!
#   status: MarketStatus!
#   stepBaseQuantums: BigInt!
#   stepSize: String!
#   subticksPerTick: Int!
#   tickSize: String!
#   trades24H: BigInt!
#   volume24H: BigInt!

#   #reference
#   clobPairId: ClobPair

#   positions: [Position!]
#   trades: [Trade!]
#   candles: [Candle!]
#   payments: [Payment!]
# }

# type Trade {
#   id: ID!
#   created_at_height: Int!
#   created_at: DateTime
#   side: OrderSide
#   price: BigDecimal
#   size: BigInt
#   trade_type: TradeType

#   # ruscet only
#   market: Market
#   position: Position
# }

# type Payment {
#   id: ID!
#   createdAt: BigInt
#   createdAtHeight: Int
#   ticker: String
#   oraclePrice: String
#   size: String
#   side: PositionSide
#   rate: String
#   payment: String
#   subaccountNumber: Int
#   fundingIndex: String

#   # Utility
#   type: PaymentType

#   #FKs
#   position: Position
#   market: Market
# }

# type Asset {
#   id: ID!

#   decimals: Int
#   whitelisted: Boolean
#   stable: Boolean
#   shortable: Boolean
#   min_profit_basis_points: Int
#   weight: BigDecimal

#   feed_id: String
#   price: BigDecimal
#   metadata: JSON
# }

# type Price {
#   price: String!
#   timestamp: BigInt!
# }

# type Subaccount {
#   id: ID!
#   account: Account!
# }

# type Query {
#   addresses(first: Int, after: String): [Address!]!
#   address(id: ID!): Address
#   markets(first: Int, after: String, ticker: String): [Market!]!
#   market(id: ID!): Market
#   accounts(first: Int, after: String, address: String): [Account!]!
#   account(id: ID!): Account
#   positions(first: Int, after: String, status: PositionStatus, account: String, market: String, side: PositionSide): [Position!]!
#   position(id: ID!): Position
#   trades(first: Int, after: String, market: String, side: OrderSide): [Trade!]!
#   trade(id: ID!): Trade
#   payments(first: Int, after: String, market: String, type: PaymentType, side: PositionSide): [Payment!]!
#   payment(id: ID!): Payment
#   candles(first: Int, after: String, market: String, resolution: CandleResolution, from: BigInt, to: BigInt): [Candle!]!
#   candle(id: ID!): Candle
#   assets(first: Int, after: String): [Asset!]!
#   asset(id: ID!): Asset
# }

type Account @entity {
  id: ID!
  address: String # "user identity"
  subaccountNumber: Int # "leave as 0"
  subaccountId: String # "set to identity"

  # ruscet only
  isLiquidator: Boolean
  isHandler: Boolean
  isManager: Boolean

  #FK
  positions: [Position!] @derivedFrom(field: "account")
}

type Position @entity {
  id: ID! # "AssetId+Identity+timestamp from ruscet"

  status: PositionStatus
  side: PositionSide
  size: BigInt
  maxSize: BigInt
  entryPrice: BigDecimal #ruscet's average price
  exitPrice: BigDecimal
  realizedPnl: BigDecimal
  createdAt: DateTime
  createdAtHeight: Int
  sumOpen: BigDecimal
  sumClose: BigDecimal
  netFunding: BigDecimal
  unrealizedPnl: BigDecimal
  closedAt: DateTime
  subaccountNumber: Int

  # name changed
  ticker: String # used to be market
  # "MarketId.Symbol-USD from ruscet i.e. ETH-USD"

  # Ruscet only
  collateral: BigDecimal
  positionFees: BigDecimal
  entryFundingRate: BigDecimal
  reserveAmount: BigDecimal
  lastIncreasedTime: DateTime

  # FKs
  account: Account # many-to-one
  market: Market # many-to-one
  trades: [Trade!] @derivedFrom(field: "position")
  payments: [Payment!] @derivedFrom(field: "position")
}

# nuking orders as it's not required
# type Order { }


# nuking PnLTick as well
# type PnlTick {}

type PriceTick {
  id: ID!
  ticker: String,
  timestamp: DateTime,
  price: BigDecimal,
}

type Candle {
  id: ID! # "market.id+resolution+timestamp"
  ticker: String # "market.symbol"
  resolution: CandleResolution
  startedAt: DateTime
  open: BigDecimal
  close: BigDecimal
  high: BigDecimal
  low: BigDecimal

  baseTokenVolume: BigDecimal #volume accumulator in token
  usdVolume: BigDecimal #volume accumulator in usd

  startingOpenInterest: BigDecimal # open interest at beginning of candle period

  # relations
  market: Market
}

type Market @entity {
  id: ID!
# Typical values for something with 9 decimals
# "atomicResolution": -9,
#   "tickSize": "0.01",
#   "stepSize": "1",
#   "stepBaseQuantums": 1000000000,
#   "subticksPerTick": 100000,
#   "quantumConversionExponent": -6

  atomicResolution: Int! # -Decimals e.g. -9 for most fuel assets
  baseOpenInterest: String! # We'll set this to zero
  defaultFundingRate1H: BigDecimal!
  initialMarginFraction: BigDecimal!
  maintenanceMarginFraction: BigDecimal!
  marketType: MarketType!
  nextFundingRate: BigDecimal!
  openInterest: BigDecimal!
  openInterestLowerCap: BigDecimal
  openInterestUpperCap: BigDecimal
  oraclePrice: BigDecimal
  priceChange24H: BigDecimal!
  quantumConversionExponent: Int!
  status: MarketStatus!
  stepBaseQuantums: BigInt!
  stepSize: BigDecimal!
  subticksPerTick: Int! #32 bit integer
  tickSize: BigDecimal!
  ticker: String! # AssetSymbol-USD
  trades24H: BigDecimal!
  volume24H: BigDecimal!

  # reference
  clobPairId: Int #32 bit integer
  # id: ID!
  # ruscet: String
  # dydx: String
  #
  # is_initialized: Boolean
  # average_price: Decimal
  # is_global_short_data_ready: Boolean
  # max_leverage: Decimal
  # decimals: Int
  # whitelisted: Boolean
  # stable: Boolean
  # shortable: Boolean
  # min_profit_basis_points: Int
  # weight: Decimal
  # buffer_amount: Decimal
  # last_funding_time: DateTime
  # cumulative_funding_rate: Decimal
  # fee_reserve: Decimal
  # pool_amount: Decimal
  # reserved_amount: Decimal
  # size: Decimal
  # max_size: Decimal
  # ordinal: Int
  # guaranteed_usd: Decimal
  # lock: Boolean
  # has_dynamic_fees: Boolean
  # min_profit_time: BigInt
  # router: String
  #
  # rusd_contr: String
  # rusd: String
  # pricefeed_provider: String
  # liquidation_fee_usd: Decimal
  # tax_basis_points: Int
  # stable_tax_basis_points: Int
  # mint_burn_fee_basis_points: Int
  # swap_fee_basis_points: Int
  # stable_swap_fee_basis_points: Int
  # margin_fee_basis_points: Int
  # total_asset_weights: Decimal
  # whitelisted_asset_count: Int
  # funding_interval: BigInt
  # funding_rate_factor: Int
  # stable_funding_rate_factor: Int
  #
  # ticker: String
  # market_type: MarketType
  # metadata: JSON
  #
  # price_feed: PriceFeed
  # candles(first: Int, after: String, interval: CandleResolution): CandleConnection
  # fundingPayments(first: Int, after: String): FundingPaymentConnection
  # orders(first: Int, after: String): OrderConnection
  # positions(first: Int, after: String, status: PositionStatus): PositionConnection
  # assets(first: Int, after: String): AssetConnection
  # trades(first: Int, after: String): TradeConnection

  positions: [Position!] @derivedFrom(field: "market")
  trades: [Trade!] @derivedFrom(field: "market")
  candles: [Candle!] @derivedFrom(field: "market")
  payments: [Payment!] @derivedFrom(field: "market")
}

type Trade @entity {
  id: ID!
  createdAtHeight: Int!
  createdAt: DateTime
  side: OrderSide
  price: BigDecimal
  size: BigDecimal
  tradeType: TradeType # always llimit

  # ruscet only
  market: Market
  position: Position
}

type Payment @entity {
  id: ID!
  createdAt: DateTime
  createdAtHeight: Int
  ticker: String
  oraclePrice: BigDecimal
  size: BigDecimal
  side: PositionSide
  rate: BigDecimal
  payment: BigDecimal
  subaccountNumber: Int #0
  fundingIndex: BigDecimal

  # Utility
  type: PaymentType

  #FKs
  position: Position # renamed from perpetualId
  market: Market
}

# TODO: There appears to be some overlap between asset and market currently
type Asset @entity {
  id: ID!

  decimals: Int
  whitelisted: Boolean
  stable: Boolean
  shortable: Boolean
  minProfitBasisPoints: Int
  weight: BigDecimal

  feedId: String
  price: BigDecimal
}
